// Copyright 2017 The Neugram Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package gengo implements a backend for the Neugram parser and
// typechecker that generates a Go package.
package gengo

import (
	"bytes"
	"fmt"
	"go/constant"
	"path/filepath"
	"unicode"
	"unicode/utf8"

	"neugram.io/ng/format"
	"neugram.io/ng/syntax/expr"
	"neugram.io/ng/syntax/stmt"
	"neugram.io/ng/syntax/tipe"
	"neugram.io/ng/syntax/token"
	"neugram.io/ng/typecheck"
)

func GenGo(filename string) (result []byte, err error) {
	c := typecheck.New(filename) // TODO: extract a pkg name
	path, err := filepath.Abs(filename)
	if err != nil {
		return nil, err
	}

	pkg, err := c.Check(path)
	if err != nil {
		return nil, err
	}

	p := &printer{
		buf: new(bytes.Buffer),
	}
	p.printf(`// generated by ng, do not edit

package %s

`, filepath.Base(filename))

	// Lift export declarations to the top-level.
	for _, obj := range pkg.Exported {
		switch obj.Kind {
		case typecheck.ObjType:
			p.printf("type %s %s", obj.Name, format.Type(obj.Type.(*tipe.Named).Type))
			p.newline()
			p.newline()
		case typecheck.ObjVar:
			p.printf("var %s %s", obj.Name, format.Type(obj.Type))
			p.newline()
			p.newline()
		case typecheck.ObjConst:
			p.printf("const %s %s = %s", obj.Name, format.Type(obj.Type), obj.Decl.(constant.Value))
			p.newline()
			p.newline()
		}
	}

	// TODO: Lift imports to the top-level.
	// TODO: Lift methodik declarations to the top-level.
	//       (Both of these are blocked on a visitor API.)

	p.print("func init() {")
	p.indent++
	for _, s := range pkg.Syntax.Stmts {
		p.newline()
		p.stmt(s)
	}
	p.indent--
	p.newline()
	p.print("}")

	fmt.Printf("gengo: %s\n", p.buf.String())

	return nil, fmt.Errorf("GenGo TODO")
}

type printer struct {
	buf    *bytes.Buffer
	indent int
}

func (p *printer) printf(format string, args ...interface{}) {
	fmt.Fprintf(p.buf, format, args...)
}

func (p *printer) print(str string) {
	p.buf.WriteString(str)
}

func (p *printer) newline() {
	p.buf.WriteByte('\n')
	for i := 0; i < p.indent; i++ {
		p.buf.WriteByte('\t')
	}
}

func (p *printer) expr(e expr.Expr) {
	switch e := e.(type) {
	case *expr.BasicLiteral:
		p.printf("%s", e.Value)
	case *expr.Binary:
		p.expr(e.Left)
		p.printf(" %s ", e.Op)
		p.expr(e.Right)
	case *expr.Call:
		p.expr(e.Func)
		p.print("(")
		for i, arg := range e.Args {
			if i != 0 {
				p.print(", ")
			}
			p.expr(arg)
		}
		if e.Ellipsis {
			p.print("...")
		}
		p.print(")")
	case *expr.CompLiteral:
	case *expr.FuncLiteral:
		if e.Name != "" {
			p.printf("%s := ", e.Name)
		}
		p.print("func(")
		for i, name := range e.ParamNames {
			if i != 0 {
				p.print(", ")
			}
			p.print(name)
			p.print(" ")
			p.print(format.Type(e.Type.Params.Elems[i]))
		}
		p.print(") ")
		if len(e.ResultNames) != 0 {
			p.print("(")
			for i, name := range e.ResultNames {
				if i != 0 {
					p.print(", ")
				}
				p.print(name)
				p.print(" ")
				p.print(format.Type(e.Type.Results.Elems[i]))
			}
			p.print(")")
		}
		if e.Body != nil {
			p.print(" ")
			p.stmt(e.Body.(*stmt.Block))
		}
	case *expr.Ident:
		p.print(e.Name)
	case *expr.Index:
	case *expr.MapLiteral:
	case *expr.Selector:
	case *expr.Shell:
	case *expr.SliceLiteral:
	case *expr.Type:
	case *expr.TypeAssert:
	case *expr.Unary:
		p.print(e.Op.String())
		p.expr(e.Expr)
		if e.Op == token.LeftParen {
			p.print(")")
		}
	}
}

func (p *printer) stmt(s stmt.Stmt) {
	switch s := s.(type) {
	case *stmt.Assign:
		for i, e := range s.Left {
			if i != 0 {
				p.print(", ")
			}
			p.expr(e)
		}
		// TODO: A, b := ...
		if ident, isIdent := s.Left[0].(*expr.Ident); !isIdent || isExported(ident.Name) || !s.Decl {
			p.print(" = ")
		} else {
			p.print(" := ")
		}
		for i, e := range s.Right {
			if i != 0 {
				p.print(", ")
			}
			p.expr(e)
		}
	case *stmt.Block:
		p.print("{")
		p.indent++
		for _, s := range s.Stmts {
			p.newline()
			p.stmt(s)
		}
		p.indent--
		p.newline()
		p.print("}")
	case *stmt.For:
	case *stmt.Go:
	case *stmt.If:
		p.print("if ")
		if s.Init != nil {
			p.stmt(s.Init)
			p.print("; ")
		}
		p.expr(s.Cond)
		p.print(" ")
		p.stmt(s.Body)
	case *stmt.ImportSet:
		// lifted to top-level earlier
	case *stmt.Import:
		// lifted to top-level earlier
	case *stmt.Range:
	case *stmt.Return:
	case *stmt.Simple:
	case *stmt.Send:
	case *stmt.TypeDecl:
	case *stmt.MethodikDecl:
		// lifted to top-level earlier
	case *stmt.Labeled:
	case *stmt.Branch:
	case *stmt.Switch:
	case *stmt.TypeSwitch:
	case *stmt.Select:
	}
}

func isExported(name string) bool {
	ch, _ := utf8.DecodeRuneInString(name)
	return unicode.IsUpper(ch)
}
