// Copyright 2017 The Neugram Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package gengo implements a backend for the Neugram parser and
// typechecker that generates a Go package.
package gengo

import (
	"bytes"
	"fmt"
	"go/constant"
	"path"
	"path/filepath"
	"unicode"
	"unicode/utf8"

	"neugram.io/ng/format"
	"neugram.io/ng/syntax"
	"neugram.io/ng/syntax/expr"
	"neugram.io/ng/syntax/stmt"
	"neugram.io/ng/syntax/tipe"
	"neugram.io/ng/syntax/token"
	"neugram.io/ng/typecheck"
)

func GenGo(filename string) (result []byte, err error) {
	p := &printer{
		buf:     new(bytes.Buffer),
		c:       typecheck.New(filename), // TODO: extract a pkg name
		imports: make(map[*tipe.Package]string),
	}

	abspath, err := filepath.Abs(filename)
	if err != nil {
		return nil, err
	}

	pkg, err := p.c.Check(abspath)
	if err != nil {
		return nil, err
	}

	p.printf(`// generated by ng, do not edit

package %s

`, filepath.Base(filename))

	// Lift imports to the top-level.
	var importPaths []string
	preFn := func(c *syntax.Cursor) bool {
		switch node := c.Node.(type) {
		case *stmt.Import:
			importPaths = append(importPaths, node.Path)
			//fmt.Printf("import type:
		}
		return true
	}
	syntax.Walk(pkg.Syntax, preFn, nil)
	if len(importPaths) > 0 {
		// De-dup.
		importSet := make(map[string]bool)
		for _, imp := range importPaths {
			importSet[imp] = true
		}
		// Name.
		namedImports := make(map[string]string) // name -> path
		for imp := range importSet {
			name := "gengoimp_" + path.Base(imp)
			i := 0
			for namedImports[name] != "" {
				i++
				name = fmt.Sprintf("gengoimp_%s_%d", path.Base(imp), i)
			}
			namedImports[name] = imp
			p.imports[p.c.Pkg(imp).Type] = name
		}

		p.printf("import (")
		p.indent++

		// Stable output is ensured by gofmt's sorting later.
		for name, imp := range namedImports {
			p.newline()
			p.printf("%s %q", name, imp)
		}

		p.indent--
		p.newline()
		p.print(")")
		p.newline()
		p.newline()
	}

	// Lift export declarations to the top-level.
	for _, obj := range pkg.Exported {
		switch obj.Kind {
		case typecheck.ObjType:
			p.printf("type %s %s", obj.Name, format.Type(obj.Type.(*tipe.Named).Type))
			p.newline()
			p.newline()
		case typecheck.ObjVar:
			p.printf("var %s %s", obj.Name, format.Type(obj.Type))
			p.newline()
			p.newline()
		case typecheck.ObjConst:
			p.printf("const %s %s = %s", obj.Name, format.Type(obj.Type), obj.Decl.(constant.Value))
			p.newline()
			p.newline()
		}
	}

	// TODO: Lift methodik declarations to the top-level.
	//       (Both of these are blocked on a visitor API.)

	p.print("func init() {")
	p.indent++
	for _, s := range pkg.Syntax.Stmts {
		p.newline()
		p.stmt(s)
	}
	p.indent--
	p.newline()
	p.print("}")

	fmt.Printf("gengo: %s\n", p.buf.String())

	return nil, fmt.Errorf("GenGo TODO")
}

type printer struct {
	buf    *bytes.Buffer
	indent int

	imports map[*tipe.Package]string // import package -> name
	c       *typecheck.Checker
}

func (p *printer) printf(format string, args ...interface{}) {
	fmt.Fprintf(p.buf, format, args...)
}

func (p *printer) print(str string) {
	p.buf.WriteString(str)
}

func (p *printer) newline() {
	p.buf.WriteByte('\n')
	for i := 0; i < p.indent; i++ {
		p.buf.WriteByte('\t')
	}
}

func (p *printer) expr(e expr.Expr) {
	switch e := e.(type) {
	case *expr.BasicLiteral:
		if str, isStr := e.Value.(string); isStr {
			p.printf("%q", str)
		} else {
			p.printf("%s", e.Value)
		}
	case *expr.Binary:
		p.expr(e.Left)
		p.printf(" %s ", e.Op)
		p.expr(e.Right)
	case *expr.Call:
		p.expr(e.Func)
		p.print("(")
		for i, arg := range e.Args {
			if i != 0 {
				p.print(", ")
			}
			p.expr(arg)
		}
		if e.Ellipsis {
			p.print("...")
		}
		p.print(")")
	case *expr.CompLiteral:
	case *expr.FuncLiteral:
		if e.Name != "" {
			p.printf("%s := ", e.Name)
		}
		p.print("func(")
		for i, name := range e.ParamNames {
			if i != 0 {
				p.print(", ")
			}
			p.print(name)
			p.print(" ")
			p.print(format.Type(e.Type.Params.Elems[i]))
		}
		p.print(") ")
		if len(e.ResultNames) != 0 {
			p.print("(")
			for i, name := range e.ResultNames {
				if i != 0 {
					p.print(", ")
				}
				p.print(name)
				p.print(" ")
				p.print(format.Type(e.Type.Results.Elems[i]))
			}
			p.print(")")
		}
		if e.Body != nil {
			p.print(" ")
			p.stmt(e.Body.(*stmt.Block))
		}
	case *expr.Ident:
		if pkgType, isPkg := p.c.Type(e).(*tipe.Package); isPkg {
			p.print(p.imports[pkgType])
		} else {
			p.print(e.Name)
		}
	case *expr.Index:
	case *expr.MapLiteral:
	case *expr.Selector:
		p.expr(e.Left)
		p.print(".")
		p.expr(e.Right)
	case *expr.Shell:
	case *expr.SliceLiteral:
	case *expr.Type:
	case *expr.TypeAssert:
	case *expr.Unary:
		p.print(e.Op.String())
		p.expr(e.Expr)
		if e.Op == token.LeftParen {
			p.print(")")
		}
	}
}

func (p *printer) stmt(s stmt.Stmt) {
	switch s := s.(type) {
	case *stmt.Assign:
		for i, e := range s.Left {
			if i != 0 {
				p.print(", ")
			}
			p.expr(e)
		}
		// TODO: A, b := ...
		if ident, isIdent := s.Left[0].(*expr.Ident); !isIdent || isExported(ident.Name) || !s.Decl {
			p.print(" = ")
		} else {
			p.print(" := ")
		}
		for i, e := range s.Right {
			if i != 0 {
				p.print(", ")
			}
			p.expr(e)
		}
	case *stmt.Block:
		p.print("{")
		p.indent++
		for _, s := range s.Stmts {
			p.newline()
			p.stmt(s)
		}
		p.indent--
		p.newline()
		p.print("}")
	case *stmt.For:
	case *stmt.Go:
	case *stmt.If:
		p.print("if ")
		if s.Init != nil {
			p.stmt(s.Init)
			p.print("; ")
		}
		p.expr(s.Cond)
		p.print(" ")
		p.stmt(s.Body)
	case *stmt.ImportSet:
		// lifted to top-level earlier
	case *stmt.Import:
		// lifted to top-level earlier
	case *stmt.Range:
	case *stmt.Return:
	case *stmt.Simple:
		p.expr(s.Expr)
	case *stmt.Send:
	case *stmt.TypeDecl:
	case *stmt.MethodikDecl:
		// lifted to top-level earlier
	case *stmt.Labeled:
	case *stmt.Branch:
	case *stmt.Switch:
	case *stmt.TypeSwitch:
	case *stmt.Select:
	}
}

func isExported(name string) bool {
	ch, _ := utf8.DecodeRuneInString(name)
	return unicode.IsUpper(ch)
}
